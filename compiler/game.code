# --- Control flow helpers --- =========================================================

macro ifNZ(r cond, macro() ifCase, macro() elseCase) {
  skipifneqn cond, 0;
  goto a;
  ifCase;
  goto done;
  a:
  elseCase;
  done:
}

# ============================================================
# ifeq / ifneq
#   ifeq(x, y,  ifCase, elseCase)
#   ifneq(x, y, ifCase, elseCase)
# ============================================================

macro ifeq(r x, r y, macro() ifCase, macro() elseCase) {
  # if (x == y) { ifCase } else { elseCase }

  skipifeq x, y;      # if x == y, skip next
  goto ifeq_else;     # executed only when x != y
  ifCase;
  goto ifeq_done;
ifeq_else:
  elseCase;
ifeq_done:
}

macro ifneq(r x, r y, macro() ifCase, macro() elseCase) {
  # if (x != y) { ifCase } else { elseCase }

  skipifneq x, y;     # if x != y, skip next
  goto ifneq_else;    # executed only when x == y
  ifCase;
  goto ifneq_done;
ifneq_else:
  elseCase;
ifneq_done:
}


# ============================================================
# Boolean NOT / AND / OR on 0 / non-zero
#
#   not(x)          : x = (!x) ? 1 : 0
#   and(out, a, b)  : out = (a != 0 && b != 0) ? 1 : 0
#   or(out, a, b)   : out = (a != 0 || b != 0) ? 1 : 0
#
# Uses your existing ifNZ(cond, ifCase, elseCase).
# ============================================================

macro not(rw x) {
  # x = (!x) ? 1 : 0
  ifNZ x,
    { setn x, 0; },   # x != 0 → false
    { setn x, 1; };   # x == 0 → true
}

macro and(rw out, r a, r b) {
  # out = (a && b) ? 1 : 0

  # First test a
  set out, a;
  ifNZ out,
    {
      # a is true, now test b
      set out, b;
      ifNZ out,
        { setn out, 1; },   # both non-zero → true
        { setn out, 0; };   # b == 0 → false
    },
    {
      # a == 0 → whole AND is false
      setn out, 0;
    };
}

macro or(rw out, r a, r b) {
  # out = (a || b) ? 1 : 0

  # First test a
  set out, a;
  ifNZ out,
    {
      # a is true → OR is true
      setn out, 1;
    },
    {
      # a == 0, so result depends on b
      set out, b;
      ifNZ out,
        { setn out, 1; },   # b != 0 → true
        { setn out, 0; };   # both zero → false
    };
}


# ============================================================
# for loops
#
# 1) forRange(i, start, end, body(i)):
#      for (i = start; i < end; ++i) body(i)
#
# 2) forCount(n, body(i)):
#      for (i = 0; i < n; ++i) body(i)
#
# Both forms pass the loop index as an rw macro argument.
# ============================================================

macro forRange(rw i, int start, int end, macro(rw) body) {
  # i runs from [start, end) (end is exclusive)

  setn i, start;
  setn limit, end;
forRange_loop:
  # if (i == limit) break;
  skipifeq i, limit;      # if i == limit, skip next
  goto forRange_body;     # executed when i != limit
  goto forRange_done;     # executed when i == limit

forRange_body:
  body i;
  addn i, 1;
  goto forRange_loop;

forRange_done:
}

macro forCount(int n, macro(rw) body) {
  # for i in [0, n): body(i)

  setn i, 0;
  setn limit, n;
forCount_loop:
  skipifeq i, limit;      # if i == limit, skip next
  goto forCount_body;     # executed when i != limit
  goto forCount_done;     # executed when i == limit

forCount_body:
  body i;
  addn i, 1;
  goto forCount_loop;

forCount_done:
}

# --- Constants and regions --- =========================================================

# --- Sprites ---

region spr_player auto 0b00000111
	             , 0b00000111
	             , 0b00001111
	             , 0b11001110
	             , 0b11111100
	             , 0b11111000
	             , 0b00111000
	             , 0b00111110

region spr_branch auto 0b11100001
	             , 0b00100011
	             , 0b01110010
	             , 0b01011010
	             , 0b01001000
	             , 0b00001000
	             , 0b10001101
	             , 0b10000001

region spr_trunk auto  0b00100000
	             , 0b00101000
	             , 0b00111100
	             , 0b01111100
	             , 0b01111111
	             , 0b11111100
	             , 0b00100010
	             , 0b01000001

region spr_eagle auto  0b10000001
	             , 0b11000011
	             , 0b11100011
	             , 0b01111110
	             , 0b00111100
	             , 0b00011000
	             , 0b00100100
	             , 0b00000000

region spr_nut auto    0b00000000
	             , 0b01111110
	             , 0b11111111
	             , 0b01111110
	             , 0b00111100
	             , 0b00111100
	             , 0b00111100
	             , 0b00011000

region spr_rattlesnake auto
		       0b00000000
	             , 0b11000000
	             , 0b11100000
	             , 0b00010000
	             , 0b00010000
	             , 0b00010110
	             , 0b01001001
	             , 0b00110110

# --- Map / tiles ---

const mapWidth      32;
const mapHeight     32;

const tileTAir      0;
const tileTBranch   1;
const tileTTrunk    2;

# Counts / packing
const tileCount     1024;   # 32 * 32
const tilesPerByte  4;      # 2 bits per tile → 4 tiles per byte
const tilemapBytes  256;    # tileCount / tilesPerByte

# tile size in pixels
const tileSize      8;

# --- Entity counts ---

const numEnemies    64;
const numNuts       16;

# single byte counters / frame counter
region enemyCounter    1;
region nutCounter      1;

# --- Global state ---

region frameCounter    1;

# --- Tilemap ---

# Packed tilemap: 4 tiles per byte, 2 bits each
region tilemap 256; #tilemapBytes;

# --- Nuts ---

const nutSlotBytes   3;     # tileX, tileY, packed flags+dx+dy
const nutSlotsBytes  48;    # numNuts * nutSlotBytes

# Packed nut layout:
#   byte 0: tileX (0..31)
#   byte 1: tileY (0..31)
#   byte 2: bits:
#       0 = buried
#       1 = thrown
#       2 = high
#       3-4 = dx code (0..3)
#       5-6 = dy code (0..3)
#       7   = unused

# Offsets from the nut slot base
const nutTileXOff    0
const nutTileYOff    1
const nutFlagsOff    2       # buried/thrown/high + dx/dy codes

const nutFlagBuriedBit   0;
const nutFlagThrownBit   1;
const nutFlagHighBit     2;
const nutDxShift         3;   # 2 bits, 3-4
const nutDyShift         5;   # 2 bits, 5-6

region nutSlots 48; #nutSlotsBytes;

# --- Nut helpers ---

/* Compute byte offset of nut slot `idx`:
   off = idx * nutSlotBytes (3)
*/
macro nutSlotOffset(r idx, rw off) {
  set off, idx;
  add off, idx;     # off = 2*idx
  add off, idx;     # off = 3*idx
}

/* Load a single byte from nutSlots[idx] at field offset `fieldOff` */
macro nutLoadByte(r idx, int fieldOff, w out) {
  nutSlotOffset idx, off;
  addn off, fieldOff;
  seti nutSlots;
  addi off;
  regload;
  getzero out;
}

/* Store a single byte into nutSlots[idx] at field offset `fieldOff` */
macro nutStoreByte(r idx, int fieldOff, r val) {
  nutSlotOffset idx, off;
  addn off, fieldOff;
  seti nutSlots;
  addi off;
  setzero val;
  regdump;
}

macro nutGetTileX(r idx, w outX) {
  nutLoadByte idx, nutTileXOff, outX;
}

macro nutSetTileX(r idx, r inX) {
  nutStoreByte idx, nutTileXOff, inX;
}

macro nutGetTileY(r idx, w outY) {
  nutLoadByte idx, nutTileYOff, outY;
}

macro nutSetTileY(r idx, r inY) {
  nutStoreByte idx, nutTileYOff, inY;
}

macro nutGetFlags(r idx, w flags) {
  nutLoadByte idx, nutFlagsOff, flags;
}

macro nutSetFlags(r idx, r flags) {
  nutStoreByte idx, nutFlagsOff, flags;
}

# --- Buried flag (bit 0) ---

macro nutSetBuried(r idx) {
  nutGetFlags idx, flags;
  setn mask, 1;           # 1 << 0
  bor flags, mask;
  nutSetFlags idx, flags;
}

macro nutClearBuried(r idx) {
  nutGetFlags idx, flags;
  setn mask, 1;           # 1 << 0
  setn full, 255;
  bxor full, mask;        # full = ~mask
  band flags, full;
  nutSetFlags idx, flags;
}

macro nutGetBuried(r idx, w out) {
  nutGetFlags idx, flags;
  setn mask, 1;
  band flags, mask;
  set out, flags;         # out = 0 or 1
}

# --- Thrown flag (bit 1) ---

macro nutSetThrown(r idx) {
  nutGetFlags idx, flags;
  setn mask, 2;           # 1 << 1
  bor flags, mask;
  nutSetFlags idx, flags;
}

macro nutClearThrown(r idx) {
  nutGetFlags idx, flags;
  setn mask, 2;
  setn full, 255;
  bxor full, mask;        # full = ~mask
  band flags, full;
  nutSetFlags idx, flags;
}

macro nutGetThrown(r idx, w out) {
  nutGetFlags idx, flags;
  setn mask, 2;
  band flags, mask;
  set out, flags;         # 0 or 2
}

# --- High flag (bit 2) ---

macro nutSetHigh(r idx) {
  nutGetFlags idx, flags;
  setn mask, 4;           # 1 << 2
  bor flags, mask;
  nutSetFlags idx, flags;
}

macro nutClearHigh(r idx) {
  nutGetFlags idx, flags;
  setn mask, 4;
  setn full, 255;
  bxor full, mask;        # full = ~mask
  band flags, full;
  nutSetFlags idx, flags;
}

macro nutGetHigh(r idx, w out) {
  nutGetFlags idx, flags;
  setn mask, 4;
  band flags, mask;
  set out, flags;         # 0 or 4
}

# --- Enemies ---

const numEnemies        64;
const enemySlotBytes    4;      # tileX, tileY, dmgFrameCounter, moveCounter+flag
const enemySlotsBytes   256;    # numEnemies * enemySlotBytes

# Packed enemy layout:
#   byte 0: tileX (0..31)
#   byte 1: tileY (0..31)
#   byte 2: damagedPlayerFrameCounter (0..255)
#   byte 3: bits:
#       7   = canDamagePlayer
#       0-6 = moveCounter (0..127)

# Offsets from the enemy slot base
const enemyTileXOff       0
const enemyTileYOff       1
const enemyDmgCounterOff  2
const enemyMoveFlagsOff   3       # moveCounter + canDamagePlayer bit

# Bit within the byte at enemyMoveFlagsOff
const enemyCanDamageBit 7;      # in byte 3 of the slot

region enemySlots 256; #enemySlotsBytes;

# --- Enemy helpers ---

/* Compute byte offset of enemy slot `idx`:
   off = idx * enemySlotBytes (4)
*/
macro enemySlotOffset(r idx, rw off) {
  set off, idx;
  shl off;          # *2
  shl off;          # *4
}

/* Load a single byte from enemySlots[idx] at field offset `fieldOff` */
macro enemyLoadByte(r idx, int fieldOff, w out) {
  enemySlotOffset idx, off;
  addn off, fieldOff;
  seti enemySlots;
  addi off;
  regload;
  getzero out;
}

/* Store a single byte into enemySlots[idx] at field offset `fieldOff` */
macro enemyStoreByte(r idx, int fieldOff, r val) {
  enemySlotOffset idx, off;
  addn off, fieldOff;
  seti enemySlots;
  addi off;
  setzero val;
  regdump;
}

macro enemyGetTileX(r idx, w outX) {
  enemyLoadByte idx, enemyTileXOff, outX;
}

macro enemySetTileX(r idx, r inX) {
  enemyStoreByte idx, enemyTileXOff, inX;
}

macro enemyGetTileY(r idx, w outY) {
  enemyLoadByte idx, enemyTileYOff, outY;
}

macro enemySetTileY(r idx, r inY) {
  enemyStoreByte idx, enemyTileYOff, inY;
}

macro enemyGetDamageCounter(r idx, w out) {
  enemyLoadByte idx, enemyDmgCounterOff, out;
}

macro enemySetDamageCounter(r idx, r val) {
  enemyStoreByte idx, enemyDmgCounterOff, val;
}

macro enemyGetMoveCounter(r idx, w out) {
  enemyLoadByte idx, enemyMoveFlagsOff, b;
  setn mask, 127;        # 0x7F
  band b, mask;          # keep low 7 bits
  set out, b;
}

/* move is treated as 0..127; high bit is preserved */
macro enemySetMoveCounter(r idx, r move) {
  enemyLoadByte idx, enemyMoveFlagsOff, b;

  # newByte = (old & 0x80) | (move & 0x7F)
  set newByte, b;
  setn maskHi, 128;      # 0x80
  band newByte, maskHi;  # keep only canDamage bit

  set val, move;
  setn maskLo, 127;      # 0x7F
  band val, maskLo;      # clamp low 7 bits

  bor newByte, val;

  enemyStoreByte idx, enemyMoveFlagsOff, newByte;
}

/* out = 0 or 0x80 (nonzero means can damage) */
macro enemyGetCanDamage(r idx, w out) {
  enemyLoadByte idx, enemyMoveFlagsOff, b;
  setn mask, 128;        # 1 << 7
  band b, mask;
  set out, b;
}

macro enemySetCanDamage(r idx) {
  enemyLoadByte idx, enemyMoveFlagsOff, b;
  setn mask, 128;        # set bit 7
  bor b, mask;
  enemyStoreByte idx, enemyMoveFlagsOff, b;
}

macro enemyClearCanDamage(r idx) {
  enemyLoadByte idx, enemyMoveFlagsOff, b;
  setn mask, 128;
  setn full, 255;
  bxor full, mask;       # full = ~mask = 0x7F
  band b, full;          # clear bit 7
  enemyStoreByte idx, enemyMoveFlagsOff, b;
}

# --- Player struct layout ---

const playerSlotBytes           6

const playerTileXOff            0
const playerTileYOff            1
const playerFlagsOff            2
const playerHpOff               3
const playerStateFramesOff      4
const playerScoreOff            5

# flags in playerFlagsOff:
const playerOnBranchBit         0   # bit 0
const playerHasAcornBit         1   # bit 1
const playerEatingBit           2   # bit 2

region player 6; #playerSlotBytes;

# --- Player helpers ---

# Load player[fieldOff] -> out
macro playerLoadByte(int fieldOff, w out) {
  setn off, fieldOff;
  seti player;
  addi off;
  regload;
  getzero out;
}

# Store val -> player[fieldOff]
macro playerStoreByte(int fieldOff, r val) {
  setn off, fieldOff;
  seti player;
  addi off;
  setzero val;
  regdump;
}

macro playerGetTileX(w outX) {
  playerLoadByte playerTileXOff, outX;
}

macro playerSetTileX(r inX) {
  playerStoreByte playerTileXOff, inX;
}

macro playerGetTileY(w outY) {
  playerLoadByte playerTileYOff, outY;
}

macro playerSetTileY(r inY) {
  playerStoreByte playerTileYOff, inY;
}

macro playerGetHp(w outHp) {
  playerLoadByte playerHpOff, outHp;
}

macro playerSetHp(r inHp) {
  playerStoreByte playerHpOff, inHp;
}

macro playerGetStateFrames(w outFrames) {
  playerLoadByte playerStateFramesOff, outFrames;
}

macro playerSetStateFrames(r inFrames) {
  playerStoreByte playerStateFramesOff, inFrames;
}

macro playerGetScore(w outScore) {
  playerLoadByte playerScoreOff, outScore;
}

macro playerSetScore(r inScore) {
  playerStoreByte playerScoreOff, inScore;
}

# Internal: load/store flags byte

macro playerGetFlags(w outFlags) {
  playerLoadByte playerFlagsOff, outFlags;
}

macro playerSetFlags(r inFlags) {
  playerStoreByte playerFlagsOff, inFlags;
}

macro playerSetOnBranch() {
  playerGetFlags flags;
  setn mask, 1;               # 1 << playerOnBranchBit
  bor flags, mask;
  playerSetFlags flags;
}

macro playerClearOnBranch() {
  playerGetFlags flags;
  setn mask, 1;
  setn full, 255;
  bxor full, mask;             # full = ~mask
  band flags, full;
  playerSetFlags flags;
}

macro playerGetOnBranch(w out) {
  playerGetFlags flags;
  setn mask, 1;
  band flags, mask;
  set out, flags;              # 0 or 1
}

macro playerSetHasAcorn() {
  playerGetFlags flags;
  setn mask, 2;               # 1 << playerHasAcornBit
  bor flags, mask;
  playerSetFlags flags;
}

macro playerClearHasAcorn() {
  playerGetFlags flags;
  setn mask, 2;
  setn full, 255;
  bxor full, mask;
  band flags, full;
  playerSetFlags flags;
}

macro playerGetHasAcorn(w out) {
  playerGetFlags flags;
  setn mask, 2;
  band flags, mask;
  set out, flags;             # 0 or 2 (nonzero means true)
}

macro playerSetEating() {
  playerGetFlags flags;
  setn mask, 4;               # 1 << playerEatingBit
  bor flags, mask;
  playerSetFlags flags;
}

macro playerClearEating() {
  playerGetFlags flags;
  setn mask, 4;
  setn full, 255;
  bxor full, mask;
  band flags, full;
  playerSetFlags flags;
}

macro playerGetEating(w out) {
  playerGetFlags flags;
  setn mask, 4;
  band flags, mask;
  set out, flags;             # 0 or 4
}

macro playerInit() {
  # tileX = 15
  setn tmp, 15;
  playerSetTileX tmp;

  # tileY = 15
  setn tmp, 15;
  playerSetTileY tmp;

  # flags: onBranch = false, acorn = false, eating = false
  setn flags, 0;
  playerSetFlags flags;

  # hp = 3
  setn tmp, 3;
  playerSetHp tmp;

  # stateFrames = 0
  setn tmp, 0;
  playerSetStateFrames tmp;

  # score = 0
  setn tmp, 0;
  playerSetScore tmp;
}

# --- Tilemap helpers ---

# Given tileX, tileY (0..31), compute:
#   byteIdx : which byte in tilemap
#   subIdx  : which 2-bit slot (0..3)
macro tileCoordToByteAndSubIndex(r tileX, r tileY, rw byteIdx, rw subIdx) {
  # byteIdx = tileY * 8
  set byteIdx, tileY;
  shl byteIdx;       # *2
  shl byteIdx;       # *4
  shl byteIdx;       # *8

  # xDiv4 = tileX / 4
  set xDiv4, tileX;
  shr xDiv4;         # /2
  shr xDiv4;         # /4

  add byteIdx, xDiv4;

  # subIdx = tileX & 3
  set subIdx, tileX;
  setn mask3, 3;
  band subIdx, mask3;
}

macro tileLoadByte(r byteIdx, w tileByte) {
  seti tilemap;
  addi byteIdx;
  regload;
  getzero tileByte;
}

# tileType out: 0=air,1=branch,2=trunk (etc)
macro tileGetType(r tileX, r tileY, w tileType) {
  tileCoordToByteAndSubIndex tileX, tileY, byteIdx, subIdx;
  tileLoadByte byteIdx, tileByte;

  # Case: subIdx == 0
  set idx, subIdx;
  skipifeqn idx, 0;
  goto tile_case1;
  set val, tileByte;
  setn mask, 3;          # 0b11
  band val, mask;
  set tileType, val;
  goto tile_done;

tile_case1:
  # Case: subIdx == 1
  set idx, subIdx;
  skipifeqn idx, 1;
  goto tile_case2;
  set val, tileByte;
  shr val;
  shr val;               # >>2
  setn mask, 3;
  band val, mask;
  set tileType, val;
  goto tile_done;

tile_case2:
  # Case: subIdx == 2
  set idx, subIdx;
  skipifeqn idx, 2;
  goto tile_case3;
  set val, tileByte;
  shr val; shr val; shr val; shr val;   # >>4
  setn mask, 3;
  band val, mask;
  set tileType, val;
  goto tile_done;

tile_case3:
  # Case: subIdx == 3
  set val, tileByte;
  shr val; shr val; shr val; shr val; shr val; shr val;   # >>6
  setn mask, 3;
  band val, mask;
  set tileType, val;

tile_done:
}

# ============================================================
# Tile store helper (packed tilemap: 4 tiles / byte, 2 bits each)
# ============================================================

macro tileStoreByte(r byteIdx, r tileByte) {
  seti tilemap;
  addi byteIdx;
  setzero tileByte;
  regdump;
}

# tileSetType:
#   tileType: 0 = air, 1 = branch, 2 = trunk (2-bit value)
macro tileSetType(r tileX, r tileY, r tileType) {
  tileCoordToByteAndSubIndex tileX, tileY, byteIdx, subIdx;
  tileLoadByte byteIdx, tileByte;

  # val = tileType & 3 (2-bit)
  set val, tileType;
  setn mask3, 3;
  band val, mask3;

  # subIdx selects which 2-bit slot inside the byte
  set idx, subIdx;
  skipifeqn idx, 0;
  goto tileSet_case1;
  # ---- case subIdx == 0 (bits 0..1) ----
  setn maskClear, 252;         # 11111100
  band tileByte, maskClear;    # clear bits 0..1
  bor tileByte, val;           # put val at bits 0..1
  goto tileSet_write;

tileSet_case1:
  set idx, subIdx;
  skipifeqn idx, 1;
  goto tileSet_case2;
  # ---- case subIdx == 1 (bits 2..3) ----
  setn maskClear, 243;         # 11110011
  band tileByte, maskClear;    # clear bits 2..3
  shl val;                     # <<1
  shl val;                     # <<2 total
  bor tileByte, val;
  goto tileSet_write;

tileSet_case2:
  set idx, subIdx;
  skipifeqn idx, 2;
  goto tileSet_case3;
  # ---- case subIdx == 2 (bits 4..5) ----
  setn maskClear, 207;         # 11001111
  band tileByte, maskClear;    # clear bits 4..5
  shl val; shl val; shl val; shl val;   # <<4
  bor tileByte, val;
  goto tileSet_write;

tileSet_case3:
  # ---- case subIdx == 3 (bits 6..7) ----
  setn maskClear, 63;          # 00111111
  band tileByte, maskClear;    # clear bits 6..7
  shl val; shl val; shl val; shl val; shl val; shl val;   # <<6
  bor tileByte, val;

tileSet_write:
  tileStoreByte byteIdx, tileByte;
}

# Convenience wrappers for constants
macro setTileAir(r tileX, r tileY) {
  setn tType, tileTAir;
  tileSetType tileX, tileY, tType;
}

macro setTileBranch(r tileX, r tileY) {
  setn tType, tileTBranch;
  tileSetType tileX, tileY, tType;
}

macro setTileTrunk(r tileX, r tileY) {
  setn tType, tileTTrunk;
  tileSetType tileX, tileY, tType;
}


# ============================================================
# Random tile helpers (0..31) using CHIP-8 rand
#   mapWidth = mapHeight = 32, so just mask with 31
# ============================================================

macro randTileX(rw out) {
  rand out, 255;      # random byte
  setn mask, 31;      # 0b00011111
  band out, mask;     # 0..31
}

macro randTileY(rw out) {
  rand out, 255;
  setn mask, 31;
  band out, mask;
}

# --- Chance helpers ---------------------------------------------------

# Roughly "1 in 64" chance
macro randomChance1in64(macro() body) {
  rand chanceRand64, 63;      # AND 0x3F
  skipifeqn chanceRand64, 0;
  goto randomChance1in64_done;
  body;
randomChance1in64_done:
}

# Roughly "1 in 32" chance (≈ twice as likely)
macro randomChance1in32(macro() body) {
  rand chanceRand32, 31;      # AND 0x1F
  skipifeqn chanceRand32, 0;
  goto randomChance1in32_done;
  body;
randomChance1in32_done:
}

# --- Counter helpers --------------------------------------------------

macro getNutCounter(w out) {
  setn off, 0;
  seti nutCounter;
  addi off;
  regload;
  getzero out;
}

macro setNutCounter(r val) {
  setn off, 0;
  seti nutCounter;
  addi off;
  setzero val;
  regdump;
}

macro getEnemyCounter(w out) {
  setn offE, 0;
  seti enemyCounter;
  addi offE;
  regload;
  getzero out;
}

macro setEnemyCounter(r val) {
  setn offE, 0;
  seti enemyCounter;
  addi offE;
  setzero val;
  regdump;
}

# Allocate next nut slot.
#   idx: slot index (0..numNuts-1) if ok==1
#   ok : 1 = success, 0 = full
macro allocNutSlot(rw idx, w ok) {
  getNutCounter idx;
  setn limitN, numNuts;

  set tmpN, idx;
  skipifeq tmpN, limitN;
  goto allocNut_ok;
  setn ok, 0;
  goto allocNut_done;

allocNut_ok:
  setn ok, 1;
  set tmpN2, idx;
  addn tmpN2, 1;
  setNutCounter tmpN2;

allocNut_done:
}

# Allocate next enemy slot.
#   idx: slot index (0..numEnemies-1) if ok==1
#   ok : 1 = success, 0 = full
macro allocEnemySlot(rw idx, w ok) {
  getEnemyCounter idx;
  setn limitE, numEnemies;

  set tmpE, idx;
  skipifeq tmpE, limitE;
  goto allocEnemy_ok;
  setn ok, 0;
  goto allocEnemy_done;

allocEnemy_ok:
  setn ok, 1;
  set tmpE2, idx;
  addn tmpE2, 1;
  setEnemyCounter tmpE2;

allocEnemy_done:
}

# out = 1 if (mx,my) is in the center exclusion region, else 0.
# For now we only exclude the exact center tile.
macro inCenterExcludeSimple(r mx, r my, int centerX, int centerY, w out) {
  # Default: not excluded
  setn out, 0;

  set tx, mx;
  setn cxImm, centerX;
  skipifeq tx, cxImm;
  goto not_excluded_center;

  set ty, my;
  setn cyImm, centerY;
  skipifeq ty, cyImm;
  goto not_excluded_center;

  # Both coordinates match center
  setn out, 1;
  goto excl_done;

not_excluded_center:
  setn out, 0;

excl_done:
}

const levelGenTrees 20;    # number of trunk centers

# Place radius-2 "tree kernel" around (tileX, tileY).
# Uses the same neighbor set as the original circle with r=2:
#   (±1,0), (±2,0), (0,±1), (0,±2), (±1,±1)
macro placeTreeKernelRadius2(r tileX, r tileY) {
  # We'll assume tileX,tileY are at least 2 tiles away from edges,
  # enforced by scr_levelgen_init, so all +/-1, +/-2 neighbors are in-bounds.

  # (tileX-1, tileY)
  set kx, tileX;
  addn kx, 255;       # -1
  set ky, tileY;
  setTileBranch kx, ky;

  # (tileX+1, tileY)
  set kx, tileX;
  addn kx, 1;
  set ky, tileY;
  setTileBranch kx, ky;

  # (tileX-2, tileY)
  set kx, tileX;
  addn kx, 254;       # -2
  set ky, tileY;
  setTileBranch kx, ky;

  # (tileX+2, tileY)
  set kx, tileX;
  addn kx, 2;
  set ky, tileY;
  setTileBranch kx, ky;

  # (tileX, tileY-1)
  set kx, tileX;
  set ky, tileY;
  addn ky, 255;
  setTileBranch kx, ky;

  # (tileX, tileY+1)
  set kx, tileX;
  set ky, tileY;
  addn ky, 1;
  setTileBranch kx, ky;

  # (tileX, tileY-2)
  set kx, tileX;
  set ky, tileY;
  addn ky, 254;       # -2
  setTileBranch kx, ky;

  # (tileX, tileY+2)
  set kx, tileX;
  set ky, tileY;
  addn ky, 2;
  setTileBranch kx, ky;

  # (tileX-1, tileY-1)
  set kx, tileX;
  addn kx, 255;
  set ky, tileY;
  addn ky, 255;
  setTileBranch kx, ky;

  # (tileX+1, tileY-1)
  set kx, tileX;
  addn kx, 1;
  set ky, tileY;
  addn ky, 255;
  setTileBranch kx, ky;

  # (tileX-1, tileY+1)
  set kx, tileX;
  addn kx, 255;
  set ky, tileY;
  addn ky, 1;
  setTileBranch kx, ky;

  # (tileX+1, tileY+1)
  set kx, tileX;
  addn kx, 1;
  set ky, tileY;
  addn ky, 1;
  setTileBranch kx, ky;
}

# New scr_levelgen_init: bigger trees + acorns + enemies
macro scr_levelgen_init() {
  # Center in tile space for exclusions
  setn centerX, 16;      # mapWidth / 2 for 32x32
  setn centerY, 16;      # mapHeight / 2

  # --- 1. Place trunks + radius-2 branch kernel ----------------------

  setn i, 0;
  setn limitTrees, levelGenTrees;

tree_loop:
  skipifeq i, limitTrees;
  goto tree_body;
  goto tree_done;

tree_body:
  randTileX tileX;
  randTileY tileY;

  # Avoid extreme edges so kernel is always in-bounds:
  # skip if x in {0,1,30,31} or y in {0,1,30,31}
  set tx, tileX;
  setn zero, 0;
  skipifeq tx, zero;
  goto not_x0;
  goto next_tree;
not_x0:
  setn oneX, 1;
  skipifeq tx, oneX;
  goto not_x1;
  goto next_tree;
not_x1:
  setn thirty, 30;
  skipifeq tx, thirty;
  goto not_x30;
  goto next_tree;
not_x30:
  setn thirty1, 31;
  skipifeq tx, thirty1;
  goto not_x31;
  goto next_tree;
not_x31:

  set ty, tileY;
  setn zeroY, 0;
  skipifeq ty, zeroY;
  goto not_y0;
  goto next_tree;
not_y0:
  setn oneY, 1;
  skipifeq ty, oneY;
  goto not_y1;
  goto next_tree;
not_y1:
  setn thirtyY, 30;
  skipifeq ty, thirtyY;
  goto not_y30;
  goto next_tree;
not_y30:
  setn thirty1Y, 31;
  skipifeq ty, thirty1Y;
  goto not_y31;
  goto next_tree;
not_y31:

  # Center exclusion region (here: just the exact center tile)
  inCenterExcludeSimple tileX, tileY, 16, 16, excludedTree;
  setn oneFlag, 1;
  skipifeq excludedTree, oneFlag;
  goto place_tree_here;
  goto next_tree;

place_tree_here:
  # Trunk at center
  setTileTrunk tileX, tileY;
  # Surrounding branch "blob"
  placeTreeKernelRadius2 tileX, tileY;

next_tree:
  addn i, 1;
  goto tree_loop;

tree_done:

  # --- 2. Place acorns -----------------------------------------------

  # Use the same center we just used for tree exclusion
  spawnAcorns numNuts, 16, 16;

  # --- 3. Place enemies ----------------------------------------------

  # Example target counts: 8 rattlesnakes, then up to 16 total with eagles.
  #setn limR, 8;
  spawnRattlesnakes 8, 16, 16;

  #setn limE, 16;       # total enemyCounter target after eagles
  spawnEagles 16, 16, 16;
}

# Try to place one acorn at (mx,my), given center exclusion.
macro trySpawnSingleNutAt(r mx, r my, int centerX, int centerY) {
  # Exclude center region
  inCenterExcludeSimple mx, my, centerX, centerY, excludedNut;
  setn oneNut, 1;
  skipifeq excludedNut, oneNut;
  goto nut_not_excluded;
  goto nut_try_done;

nut_not_excluded:
  # tileType = get_tile(mx, my)
  tileGetType mx, my, tileType;

  # Skip trunks (no acorns on trunks)
  set tt, tileType;
  setn tTrunk, tileTTrunk;
  skipifeq tt, tTrunk;
  goto nut_not_trunk;
  goto nut_try_done;

nut_not_trunk:
  # Branch vs non-branch
  setn tBranch, tileTBranch;
  skipifeq tileType, tBranch;
  goto nut_on_nonbranch;

  # On branch tile: lower chance (roughly 1 in 64)
  randomChance1in64 {
    allocNutSlot nutIdx, nutOk;
    setn okOneN, 1;
    skipifeq nutOk, okOneN;
    goto nut_branch_skip_store;

    nutSetTileX nutIdx, mx;
    nutSetTileY nutIdx, my;
    setn flagsN, 0;
    nutSetFlags nutIdx, flagsN;

nut_branch_skip_store:
  };
  goto nut_try_done;

nut_on_nonbranch:
  # On non-branch tile: slightly higher chance (roughly 1 in 32)
  randomChance1in32 {
    allocNutSlot nutIdx2, nutOk2;
    setn okOneN2, 1;
    skipifeq nutOk2, okOneN2;
    goto nut_nonbranch_skip_store;

    nutSetTileX nutIdx2, mx;
    nutSetTileY nutIdx2, my;
    setn flagsN2, 0;
    nutSetFlags nutIdx2, flagsN2;

nut_nonbranch_skip_store:
  };

nut_try_done:
}

# Spawn acorns up to 'lim' (target nutCounter) around the map,
# using branch/non-branch chances.
macro spawnAcorns(int lim, int centerX, int centerY) {
  setn targetNut, lim;

  setn my, 0;
nut_outer_my:
  setn mx, 0;
nut_outer_mx:

    # Stop if nutCounter reached targetNut
    getNutCounter curNut;
    set tmpNutLimit, targetNut;
    skipifeq curNut, tmpNutLimit;
    goto nut_do_cell;
    goto spawnAcorns_done;

nut_do_cell:
    trySpawnSingleNutAt mx, my, centerX, centerY;

    # Next x
    addn mx, 1;
    setn maxXNut, mapWidth;
    skipifeq mx, maxXNut;
    goto nut_outer_mx;

  # Next y
  addn my, 1;
  setn maxYNut, mapHeight;
  skipifeq my, maxYNut;
  goto nut_outer_my;

spawnAcorns_done:
}

# Try to spawn a rattlesnake at (mx,my) if:
#   - not in center exclusion,
#   - tileType == tileTAir,
#   - random chance passes.
macro trySpawnRattlesnakeAt(r mx, r my, int centerX, int centerY) {
  inCenterExcludeSimple mx, my, centerX, centerY, excludedSnake;
  setn oneS, 1;
  skipifeq excludedSnake, oneS;
  goto rs_not_excluded;
  goto rs_try_done;

rs_not_excluded:
  tileGetType mx, my, tileTypeRS;

  # Only on air tiles
  set ttRS, tileTypeRS;
  setn tAir, tileTAir;
  skipifeq ttRS, tAir;
  goto rs_try_done;

  # randomEnemyChance ≈ 1.5%: we approximate with 1-in-64
  randomChance1in64 {
    allocEnemySlot eIdxRS, eOkRS;
    setn okOneRS, 1;
    skipifeq eOkRS, okOneRS;
    goto rs_skip_store;

    enemySetTileX eIdxRS, mx;
    enemySetTileY eIdxRS, my;

    setn zeroRS, 0;
    enemySetDamageCounter eIdxRS, zeroRS;
    enemySetMoveCounter eIdxRS, zeroRS;
    enemySetCanDamage eIdxRS;

rs_skip_store:
  };

rs_try_done:
}

# Spawn rattlesnakes until enemyCounter reaches 'lim'.
macro spawnRattlesnakes(int lim, int centerX, int centerY) {
  setn targetEnemiesRS, lim;

rs_outer_while:
  getEnemyCounter curErs;
  set limRS, targetEnemiesRS;
  skipifeq curErs, limRS;
  goto rs_do_sweep;
  goto rs_done;

rs_do_sweep:
  setn myRS, 0;
rs_my_loop:
  setn mxRS, 0;
rs_mx_loop:

    # Re-check target each tile
    getEnemyCounter curErs2;
    set limRS2, targetEnemiesRS;
    skipifeq curErs2, limRS2;
    goto rs_cell;
    goto rs_done;

rs_cell:
    trySpawnRattlesnakeAt mxRS, myRS, centerX, centerY;

    # Next x
    addn mxRS, 1;
    setn maxXRS, mapWidth;
    skipifeq mxRS, maxXRS;
    goto rs_mx_loop;

  # Next y
  addn myRS, 1;
  setn maxYRS, mapHeight;
  skipifeq myRS, maxYRS;
  goto rs_my_loop;

  # Another sweep if still below target
  goto rs_outer_while;

rs_done:
}

# Try to spawn an eagle at (mx,my) if:
#   - not in center exclusion,
#   - chance depends on branch vs non-branch.
macro trySpawnEagleAt(r mx, r my, int centerX, int centerY) {
  inCenterExcludeSimple mx, my, centerX, centerY, excludedE;
  setn oneE, 1;
  skipifeq excludedE, oneE;
  goto re_not_excluded;
  goto re_try_done;

re_not_excluded:
  tileGetType mx, my, tileTypeRE;

  set ttRE, tileTypeRE;
  setn tBranchRE, tileTBranch;
  skipifeq ttRE, tBranchRE;
  goto re_nonbranch;

  # On branch tiles: branchEnemyChance ≈ 2% → use 1-in-32
  randomChance1in32 {
    allocEnemySlot eIdxRE, eOkRE;
    setn okOneRE, 1;
    skipifeq eOkRE, okOneRE;
    goto re_branch_skip_store;

    enemySetTileX eIdxRE, mx;
    enemySetTileY eIdxRE, my;

    setn zeroRE, 0;
    enemySetDamageCounter eIdxRE, zeroRE;
    enemySetMoveCounter eIdxRE, zeroRE;
    enemySetCanDamage eIdxRE;

re_branch_skip_store:
  };
  goto re_try_done;

re_nonbranch:
  # On non-branch tiles: randomEnemyChance ≈ 1% → use 1-in-64
  randomChance1in64 {
    allocEnemySlot eIdxREN, eOkREN;
    setn okOneREN, 1;
    skipifeq eOkREN, okOneREN;
    goto re_nonbranch_skip_store;

    enemySetTileX eIdxREN, mx;
    enemySetTileY eIdxREN, my;

    setn zeroREN, 0;
    enemySetDamageCounter eIdxREN, zeroREN;
    enemySetMoveCounter eIdxREN, zeroREN;
    enemySetCanDamage eIdxREN;

re_nonbranch_skip_store:
  };

re_try_done:
}

# Spawn eagles until enemyCounter reaches 'lim'.
# Note: lim is the *total* enemyCounter target (after rattlesnakes).
macro spawnEagles(int lim, int centerX, int centerY) {
  setn targetEnemiesRE, lim;

re_outer_while:
  getEnemyCounter curEe;
  set limRE, targetEnemiesRE;
  skipifeq curEe, limRE;
  goto re_do_sweep;
  goto re_done;

re_do_sweep:
  setn myRE, 0;
re_my_loop:
  setn mxRE, 0;
re_mx_loop:

    # Re-check target each tile
    getEnemyCounter curEe2;
    set limRE2, targetEnemiesRE;
    skipifeq curEe2, limRE2;
    goto re_cell;
    goto re_done;

re_cell:
    trySpawnEagleAt mxRE, myRE, centerX, centerY;

    # Next x
    addn mxRE, 1;
    setn maxXRE, mapWidth;
    skipifeq mxRE, maxXRE;
    goto re_mx_loop;

  # Next y
  addn myRE, 1;
  setn maxYRE, mapHeight;
  skipifeq myRE, maxYRE;
  goto re_my_loop;

  # Another sweep if still below target
  goto re_outer_while;

re_done:
}

# --- Level gen ---

# ============================================================
# scr_level_init
#   - zero enemyCounter, nutCounter, frameCounter
#   - clear packed tilemap bytes
#   - clear nutSlots and enemySlots arrays
# ============================================================

macro scr_level_init() {
  # --- zero counters (each is a 1-byte region) ---

  setn tmp, 0;

  setn off, 0;
  seti enemyCounter;
  addi off;
  setzero tmp;
  regdump;

  setn off, 0;
  seti nutCounter;
  addi off;
  setzero tmp;
  regdump;

  setn off, 0;
  seti frameCounter;
  addi off;
  setzero tmp;
  regdump;

  # --- clear tilemap (tilemapBytes bytes) ---

  setn i, 0;
  setn limit, tilemapBytes;
scrLevelInit_tile_loop:
  skipifeq i, limit;
  goto scrLevelInit_tile_body;
  goto scrLevelInit_tile_done;

scrLevelInit_tile_body:
  seti tilemap;
  addi i;
  setzero tmp;
  regdump;
  addn i, 1;
  goto scrLevelInit_tile_loop;

scrLevelInit_tile_done:

  # --- clear nutSlots (nutSlotsBytes bytes) ---

  setn i, 0;
  setn limit, nutSlotsBytes;
scrLevelInit_nut_loop:
  skipifeq i, limit;
  goto scrLevelInit_nut_body;
  goto scrLevelInit_nut_done;

scrLevelInit_nut_body:
  seti nutSlots;
  addi i;
  setzero tmp;
  regdump;
  addn i, 1;
  goto scrLevelInit_nut_loop;

scrLevelInit_nut_done:

  # --- clear enemySlots (enemySlotsBytes bytes) ---

  setn i, 0;
  setn limit, enemySlotsBytes;
scrLevelInit_enemy_loop:
  skipifeq i, limit;
  goto scrLevelInit_enemy_body;
  goto scrLevelInit_enemy_done;

scrLevelInit_enemy_body:
  seti enemySlots;
  addi i;
  setzero tmp;
  regdump;
  addn i, 1;
  goto scrLevelInit_enemy_loop;

scrLevelInit_enemy_done:
}

# --- Camera ---

macro computeCameraFromPlayer(r tileX, r tileY, rw camX, rw camY) {
  # ---------------- X axis ----------------
  set camX, tileX;

  # If tileX in {0,1,2,3}, clamp camX = 0, no centering or high clamp.
  set t, tileX;
  skipifeqn t, 0;
  goto camx_not0;
  setn camX, 0;
  goto camx_done_x;

camx_not0:
  set t, tileX;
  skipifeqn t, 1;
  goto camx_not1;
  setn camX, 0;
  goto camx_done_x;

camx_not1:
  set t, tileX;
  skipifeqn t, 2;
  goto camx_not2;
  setn camX, 0;
  goto camx_done_x;

camx_not2:
  set t, tileX;
  skipifeqn t, 3;
  goto camx_center;
  setn camX, 0;
  goto camx_done_x;

camx_center:
  # tileX >= 4: first center: camX = tileX - 4
  addn camX, 252;         # -4

  # If tileX in {28,29,30,31}, clamp camX = 24 (right edge)
  set t, tileX;
  skipifeqn t, 28;
  goto camx_not28;
  setn camX, 24;
  goto camx_done_x;

camx_not28:
  set t, tileX;
  skipifeqn t, 29;
  goto camx_not29;
  setn camX, 24;
  goto camx_done_x;

camx_not29:
  set t, tileX;
  skipifeqn t, 30;
  goto camx_not30;
  setn camX, 24;
  goto camx_done_x;

camx_not30:
  set t, tileX;
  skipifeqn t, 31;
  goto camx_done_x;
  setn camX, 24;

camx_done_x:

  # ---------------- Y axis ----------------
  set camY, tileY;

  # If tileY in {0,1}, clamp camY = 0
  set t, tileY;
  skipifeqn t, 0;
  goto camy_not0;
  setn camY, 0;
  goto camy_done_y;

camy_not0:
  set t, tileY;
  skipifeqn t, 1;
  goto camy_center;
  setn camY, 0;
  goto camy_done_y;

camy_center:
  # tileY >= 2: center: camY = tileY - 2
  addn camY, 254;         # -2

  # If tileY in {30,31}, clamp camY = 28 (bottom edge)
  set t, tileY;
  skipifeqn t, 30;
  goto camy_not30;
  setn camY, 28;
  goto camy_done_y;

camy_not30:
  set t, tileY;
  skipifeqn t, 31;
  goto camy_done_y;
  setn camY, 28;

camy_done_y:
}

# --- Drawing helpers ---

# register spilling hacks -- just spilling manually
region worldYSpill 1;

# Draw any acorn that lives on world tile (worldX,worldY),
# at screen position (screenX,screenY).
macro drawNutsAtCell(r worldX, rw worldY, r screenX, r screenY) {
  # nutLimit = nutCounter
  getNutCounter nutLimit;

  setn nutIdx, 0;
nut_loop:
  # while (nutIdx != nutLimit)
  skipifeq nutIdx, nutLimit;
  goto nut_body;
  goto nut_done;

nut_body:
  # load this nut's tile coordinates
  nutGetTileX nutIdx, nutX;
  nutGetTileY nutIdx, nutY;

  # if nutX != worldX: continue
  set tmpX, nutX;
  skipifeq tmpX, worldX;
  goto nut_next;

  # if nutY != worldY: continue
  set tmpY, nutY;
  readMemConst worldYSpill, worldY;
  skipifeq tmpY, worldY;
  writeMemConstReg worldYSpill, worldY;
  goto nut_next;

  # match: draw a nut sprite aligned to this tile
  seti spr_nut;
  draw screenX, screenY, 8;

  # assume at most one nut per tile → break
  goto nut_done;

nut_next:
  addn nutIdx, 1;
  goto nut_loop;

nut_done:
}

# Draw any enemy that lives on world tile (worldX,worldY),
# at screen position (screenX,screenY).
#
# Convention:
#   enemy slot 0..7   : rattlesnakes (spr_rattlesnake)
#   enemy slot >= 8   : eagles      (spr_eagle)
macro drawEnemiesAtCell(r worldX, rw worldY, r screenX, r screenY) {
  # enemyLimit = enemyCounter
  getEnemyCounter enemyLimit;

  setn eIdx, 0;
enemy_loop:
  # while (eIdx != enemyLimit)
  skipifeq eIdx, enemyLimit;
  goto enemy_body;
  goto enemy_done;

enemy_body:
  # load this enemy's tile coordinates
  enemyGetTileX eIdx, ex;
  enemyGetTileY eIdx, ey;

  # if ex != worldX: continue
  set tmpX, ex;
  skipifeq tmpX, worldX;
  goto enemy_next;

  # if ey != worldY: continue
  set tmpY, ey;
  readMemConst worldYSpill, worldY;
  skipifeq tmpY, worldY;
  writeMemConstReg worldYSpill, worldY;
  goto enemy_next;

  # Tile match: choose sprite based on slot index.
  # Slots 0..7 → rattlesnake, else eagle.

  set idxCmp, eIdx;

  # eIdx == 0?
  skipifeqn idxCmp, 0;
  goto enemy_not0;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;
enemy_not0:

  # eIdx == 1?
  skipifeqn idxCmp, 1;
  goto enemy_not1;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;
enemy_not1:

  # eIdx == 2?
  skipifeqn idxCmp, 2;
  goto enemy_not2;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;
enemy_not2:

  # eIdx == 3?
  skipifeqn idxCmp, 3;
  goto enemy_not3;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;
enemy_not3:

  # eIdx == 4?
  skipifeqn idxCmp, 4;
  goto enemy_not4;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;
enemy_not4:

  # eIdx == 5?
  skipifeqn idxCmp, 5;
  goto enemy_not5;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;
enemy_not5:

  # eIdx == 6?
  skipifeqn idxCmp, 6;
  goto enemy_not6;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;
enemy_not6:

  # eIdx == 7?
  skipifeqn idxCmp, 7;
  goto enemy_default_eagle;
  seti spr_rattlesnake;
  draw screenX, screenY, 8;
  goto enemy_draw_done;

enemy_default_eagle:
  # All other slots: eagle
  seti spr_eagle;
  draw screenX, screenY, 8;

enemy_draw_done:
  # assume at most one enemy per tile → break
  goto enemy_done;

enemy_next:
  addn eIdx, 1;
  goto enemy_loop;

enemy_done:
}

macro drawViewAroundPlayer(r tileX, r tileY) {
  # Compute camera top-left in tile space
  computeCameraFromPlayer tileX, tileY, camX, camY;

  # Clear the display
  clear;

  # Outer loop: viewY = 0..3
  setn viewY, 0;
viewY_loop:
  # screenY = viewY * tileSize (8)
  set screenY, viewY;
  shl screenY;
  shl screenY;
  shl screenY;          # *8

  # worldY = camY + viewY
  readMemConst worldYSpill, worldY;
  set worldY, camY;
  add worldY, viewY;
  writeMemConstReg worldYSpill, worldY;

  # Inner loop: viewX = 0..7
  setn viewX, 0;
viewX_loop:
  # screenX = viewX * 8
  set screenX, viewX;
  shl screenX;
  shl screenX;
  shl screenX;

  # worldX = camX + viewX
  set worldX, camX;
  add worldX, viewX;

  # Get tile type
  readMemConst worldYSpill, worldY;
  tileGetType worldX, worldY, tileType;
  writeMemConstReg worldYSpill, worldY;

  # Skip air
  setn tmp, tileTAir;
  skipifeq tileType, tmp;
  goto non_air;
  goto viewX_next;

non_air:
  # Branch vs trunk
  setn tmp, tileTBranch;
  skipifeq tileType, tmp;
  goto maybe_trunk;
  seti spr_branch;
  draw screenX, screenY, 8;
  goto after_tile_sprite;

maybe_trunk:
  setn tmp, tileTTrunk;
  skipifeq tileType, tmp;
  goto after_tile_sprite;
  seti spr_trunk;
  draw screenX, screenY, 8;

after_tile_sprite:
  # Draw things that sit on this tile.
  # worldX, worldY, screenX, screenY are already set by the loops.
  drawNutsAtCell worldX, worldY, screenX, screenY;
  drawEnemiesAtCell worldX, worldY, screenX, screenY;

viewX_next:
  addn viewX, 1;
  setn limitX, 8;
  skipifeq viewX, limitX;
  goto viewX_loop;

  # Next row
  addn viewY, 1;
  setn limitY, 4;
  skipifeq viewY, limitY;
  goto viewY_loop;

  # After drawing tiles: draw player in this view
  # player is at (tileX, tileY), camera at (camX, camY)

  # relX = tileX - camX
  set relX, tileX;
  set tmpX, camX;
  sub relX, tmpX;      # relX in [0..7]

  # relY = tileY - camY
  set relY, tileY;
  set tmpY, camY;
  sub relY, tmpY;      # relY in [0..3]

  # screenX = relX * 8
  set screenX, relX;
  shl screenX;
  shl screenX;
  shl screenX;

  # screenY = relY * 8
  set screenY, relY;
  shl screenY;
  shl screenY;
  shl screenY;

  drawPlayer screenX, screenY;
  #drawPlayer tileX, tileY;
}

# --- Code --- =========================================================

macro setir(r memloc) {
  seti 0;
  addi memloc;
}

macro writeMem(r memloc, r val) {
  setir memloc;
  setzero val;
  regdump ;
}

macro readMem(r memloc, w val) {
  setir memloc;
  regload ;
  getzero val;
}

macro writeMemConst(int memloc, int val) {
  seti memloc;
  setn v, val;
  setzero v;
  regdump ;
}

macro writeMemConstReg(int memloc, r val) {
  seti memloc;
  set v, val;
  setzero v;
  regdump ;
}

macro readMemConst(int memloc, w val) {
  seti memloc;
  regload ;
  getzero val;
}

/*
  px, py   : current player position in pixels (0..63, 0..31)
  oldx,oldy: previous player position (for erase/redraw)
  key      : temp register for keypad index
*/

/* Set I to player sprite and draw it at (px, py) */
macro drawPlayer(r px, r py) {
  seti spr_player;   # sprite data at I = spr_player
  draw px, py, 8;    # 8 = sprite height
}

/*
  Movement with WASD:

    W -> chip key 5  (up)
    A -> chip key 7  (left)
    S -> chip key 8  (down)
    D -> chip key 9  (right)

  Pattern:

    setn key, N;
    skipifkey key;    # if pressed, skip goto
    goto label;       # if not pressed, jump over movement
    ... movement ...
  */

# Move player tile coordinates (tx, ty) using WASD keys.
#   A=left, D=right, W=up, S=down.
macro updatePlayerTile(rw tx, rw ty) {
  # --- LEFT (A -> key index 7) ---
  setn key, 7;
  skipifkey key;
  goto no_left;
  skipifeqn tx, 0;
  addn tx, 255;          # tx -= 1
no_left:

  # --- RIGHT (D -> key index 9) ---
  setn key, 9;
  skipifkey key;
  goto no_right;
  skipifeqn tx, 31;      # mapWidth-1
  addn tx, 1;
no_right:

  # --- UP (W -> key index 5) ---
  setn key, 5;
  skipifkey key;
  goto no_up;
  skipifeqn ty, 0;
  addn ty, 255;          # ty -= 1
no_up:

  # --- DOWN (S -> key index 8) ---
  setn key, 8;
  skipifkey key;
  goto no_down;
  skipifeqn ty, 31;      # mapHeight-1
  addn ty, 1;
no_down:
}

/*
  Simple main loop modeled after the cube example:
  - initialise px, py and oldx, oldy
  - draw once
  - in the loop: store old position, update position, erase old, draw new
*/

macro waitTicks(int n) {
  # Put n (1..255) into some temp register t
  setn t, n;
  setdelay t;          # DT := n

wait_loop:
  getdelay t;          # t := DT
  skipifeqn t, 0;      # skip next if t == 0
  goto wait_loop;      # if t != 0, keep waiting
}

macro main() {
  scr_level_init;

  # Initialise player struct as per GML (tileX=15, tileY=15, hp=3, etc.)
  playerInit;

  scr_levelgen_init;

  # Load tile pos into working registers
  playerGetTileX tx;
  playerGetTileY ty;

loop:
  # Update tile coordinates from input
  updatePlayerTile tx, ty;

  # Store back into player struct
  playerSetTileX tx;
  playerSetTileY ty;

  # Draw tiles around player + player sprite in view
  drawViewAroundPlayer tx, ty;

  # Simple frame pacing
  waitTicks 1;
  goto loop;
}
