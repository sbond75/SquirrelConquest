region player 2
const someConst 3

macro setir(r memloc) {
  seti 0;
  addi memloc;
}

macro writeMem(r memloc, r val) {
  setir memloc;
  setzero val;
  regdump ;
}

macro readMem(r memloc, w val) {
  setir memloc;
  regload ;
  getzero val;
}

macro writeMemConst(int memloc, int val) {
  seti memloc;
  setn v, val;
  setzero v;
  regdump ;
}

/*
  px, py   : current player position in pixels (0..63, 0..31)
  oldx,oldy: previous player position (for erase/redraw)
  key      : temp register for keypad index
*/

/* Set I to player sprite and draw it at (px, py) */
macro drawPlayer(r px, r py) {
  seti player;          # TODO: sprite data at I = player
  draw px, py, 5;    # TODO: 5 = sprite height
}

/* Erase sprite at old position using XOR draw */
macro erasePlayer(r oldx, r oldy) {
  seti player;
  draw oldx, oldy, 5;
}

/*
  Movement with WASD:

    W -> chip key 5  (up)
    A -> chip key 7  (left)
    S -> chip key 8  (down)
    D -> chip key 9  (right)

  Pattern:

    setn key, N;
    skipifkey key;    # if pressed, skip goto
    goto label;       # if not pressed, jump over movement
    ... movement ...
  */

macro updatePlayer(rw px, rw py) {
  # --- LEFT (A -> key index 7) ---
  setn key, 7;
  skipifkey key;
  goto no_left;
  skipifeqn px, 0;
  addn px, 255;          # -1 mod 256
no_left:

  # --- RIGHT (D -> key index 9) ---
  setn key, 9;
  skipifkey key;
  goto no_right;
  skipifeqn px, 63;      # clamp to screen width 64
  addn px, 1;
no_right:

  # --- UP (W -> key index 5) ---
  setn key, 5;
  skipifkey key;
  goto no_up;
  skipifeqn py, 0;
  addn py, 255;          # -1
no_up:

  # --- DOWN (S -> key index 8) ---
  setn key, 8;
  skipifkey key;
  goto no_down;
  skipifeqn py, 31;      # clamp to screen height 32
  addn py, 1;
no_down:
}

/*
  Only erase/redraw if the player actually moved.
*/
macro redrawIfMoved(r px, r py, r oldx, r oldy) {
  set movedx, px;
  skipifeq movedx, oldx;
  goto moved;

  set movedy, py;
  skipifeq movedy, oldy;
  goto moved;

  goto nomove;

moved:
  erasePlayer oldx, oldy;
  drawPlayer px, py;
nomove:
}

/*
  Simple main loop modeled after the cube example:
  - initialise px, py and oldx, oldy
  - draw once
  - in the loop: store old position, update position, erase old, draw new
*/

macro waitTicks(int n) {
  # Put n (1..255) into some temp register t
  setn t, n;
  setdelay t;          # DT := n

wait_loop:
  getdelay t;          # t := DT
  skipifeqn t, 0;      # skip next if t == 0
  goto wait_loop;      # if t != 0, keep waiting
}

macro main() {
  setn px, someConst;
  setn py, 16;

  set oldx, px;
  set oldy, py;
  drawPlayer px, py;

loop:
  set oldx, px;
  set oldy, py;

  updatePlayer px, py;

  erasePlayer oldx, oldy;
  drawPlayer px, py;

  waitTicks 1;       # one 60 Hz tick per game step
  goto loop;
}

