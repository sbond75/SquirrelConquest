# --- Constants and regions --- =========================================================

# --- Sprites ---

region spr_player auto 0b00000111, 0b00000111

# --- Map / tiles ---

const mapWidth      32;
const mapHeight     32;

const tileTAir      0;
const tileTBranch   1;
const tileTTrunk    1;      # matches your GML

# Counts / packing
const tileCount     1024;   # 32 * 32
const tilesPerByte  4;      # 2 bits per tile â†’ 4 tiles per byte
const tilemapBytes  256;    # tileCount / tilesPerByte

# tile size in pixels
const tileSize      8;

# --- Entity counts ---

const numEnemies    64;
const numNuts       16;

# single byte counters / frame counter
region enemyCounter    1;
region nutCounter      1;

# --- Global state ---

region frameCounter    1;

# --- Tilemap ---

# Packed tilemap: 4 tiles per byte, 2 bits each
region tilemap 256; #tilemapBytes;

# --- Nuts ---

const nutSlotBytes   3;     # tileX, tileY, packed flags+dx+dy
const nutSlotsBytes  48;    # numNuts * nutSlotBytes

# Packed nut layout:
#   byte 0: tileX (0..31)
#   byte 1: tileY (0..31)
#   byte 2: bits:
#       0 = buried
#       1 = thrown
#       2 = high
#       3-4 = dx code (0..3)
#       5-6 = dy code (0..3)
#       7   = unused

# Offsets from the nut slot base
const nutTileXOff    0
const nutTileYOff    1
const nutFlagsOff    2       # buried/thrown/high + dx/dy codes

const nutFlagBuriedBit   0;
const nutFlagThrownBit   1;
const nutFlagHighBit     2;
const nutDxShift         3;   # 2 bits, 3-4
const nutDyShift         5;   # 2 bits, 5-6

region nutSlots 48; #nutSlotsBytes;

# --- Enemies ---

const numEnemies        64;
const enemySlotBytes    4;      # tileX, tileY, dmgFrameCounter, moveCounter+flag
const enemySlotsBytes   256;    # numEnemies * enemySlotBytes

# Packed enemy layout:
#   byte 0: tileX (0..31)
#   byte 1: tileY (0..31)
#   byte 2: damagedPlayerFrameCounter (0..255)
#   byte 3: bits:
#       7   = canDamagePlayer
#       0-6 = moveCounter (0..127)

# Offsets from the enemy slot base
const enemyTileXOff       0
const enemyTileYOff       1
const enemyDmgCounterOff  2
const enemyMoveFlagsOff   3       # moveCounter + canDamagePlayer bit

# Bit within the byte at enemyMoveFlagsOff
const enemyCanDamageBit 7;      # in byte 3 of the slot

region enemySlots 256; #enemySlotsBytes;

# --- Code --- =========================================================

macro setir(r memloc) {
  seti 0;
  addi memloc;
}

macro writeMem(r memloc, r val) {
  setir memloc;
  setzero val;
  regdump ;
}

macro readMem(r memloc, w val) {
  setir memloc;
  regload ;
  getzero val;
}

macro writeMemConst(int memloc, int val) {
  seti memloc;
  setn v, val;
  setzero v;
  regdump ;
}

/*
  px, py   : current player position in pixels (0..63, 0..31)
  oldx,oldy: previous player position (for erase/redraw)
  key      : temp register for keypad index
*/

/* Set I to player sprite and draw it at (px, py) */
macro drawPlayer(r px, r py) {
  seti player;          # TODO: sprite data at I = player
  draw px, py, 5;    # TODO: 5 = sprite height
}

/* Erase sprite at old position using XOR draw */
macro erasePlayer(r oldx, r oldy) {
  seti player;
  draw oldx, oldy, 5;
}

/*
  Movement with WASD:

    W -> chip key 5  (up)
    A -> chip key 7  (left)
    S -> chip key 8  (down)
    D -> chip key 9  (right)

  Pattern:

    setn key, N;
    skipifkey key;    # if pressed, skip goto
    goto label;       # if not pressed, jump over movement
    ... movement ...
  */

macro updatePlayer(rw px, rw py) {
  # --- LEFT (A -> key index 7) ---
  setn key, 7;
  skipifkey key;
  goto no_left;
  skipifeqn px, 0;
  addn px, 255;          # -1 mod 256
no_left:

  # --- RIGHT (D -> key index 9) ---
  setn key, 9;
  skipifkey key;
  goto no_right;
  skipifeqn px, 63;      # clamp to screen width 64
  addn px, 1;
no_right:

  # --- UP (W -> key index 5) ---
  setn key, 5;
  skipifkey key;
  goto no_up;
  skipifeqn py, 0;
  addn py, 255;          # -1
no_up:

  # --- DOWN (S -> key index 8) ---
  setn key, 8;
  skipifkey key;
  goto no_down;
  skipifeqn py, 31;      # clamp to screen height 32
  addn py, 1;
no_down:
}

/*
  Only erase/redraw if the player actually moved.
*/
macro redrawIfMoved(r px, r py, r oldx, r oldy) {
  set movedx, px;
  skipifeq movedx, oldx;
  goto moved;

  set movedy, py;
  skipifeq movedy, oldy;
  goto moved;

  goto nomove;

moved:
  erasePlayer oldx, oldy;
  drawPlayer px, py;
nomove:
}

/*
  Simple main loop modeled after the cube example:
  - initialise px, py and oldx, oldy
  - draw once
  - in the loop: store old position, update position, erase old, draw new
*/

macro waitTicks(int n) {
  # Put n (1..255) into some temp register t
  setn t, n;
  setdelay t;          # DT := n

wait_loop:
  getdelay t;          # t := DT
  skipifeqn t, 0;      # skip next if t == 0
  goto wait_loop;      # if t != 0, keep waiting
}

macro main() {
  setn px, 16;
  setn py, 16;

  set oldx, px;
  set oldy, py;
  drawPlayer px, py;

loop:
  set oldx, px;
  set oldy, py;

  updatePlayer px, py;

  erasePlayer oldx, oldy;
  drawPlayer px, py;

  waitTicks 1;       # one 60 Hz tick per game step
  goto loop;
}

